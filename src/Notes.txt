#include <iostream>
#include <vector>
#include <functional>
#include <string>

class Menu {
public:
    struct MenuItem {
        std::string title;
        bool visible;
        bool state;
        std::function<void(MenuItem&)> action;

        MenuItem(const std::string& t, bool v = true, bool s = false, std::function<void(MenuItem&)> a = nullptr)
            : title(t), visible(v), state(s), action(a) {}
    };

    Menu(const std::string& heading) : heading(heading), currentLevel(0), selectedItem(0), lastSelectedItem(0), previousMenu(nullptr) {}

    void addMenuItem(const std::string& title, bool visible = true, bool state = false, std::function<void(MenuItem&)> action = nullptr) {
        entries.emplace_back(title, visible, state, action);
    }

    void addSubMenu(const std::string& title, Menu* submenu) {
        submenu->previousMenu = this;
        subMenus.push_back(submenu);
        addMenuItem(title, true, false, [this, submenu](Menu::MenuItem&) {
            lastSelectedItem = selectedItem;
            *this = *submenu;
            selectedItem = 0;
        });
    }

    void navigateUp() {
        if (selectedItem > 0) {
            --selectedItem;
        }
    }

    void navigateDown() {
        if (selectedItem < entries.size()) {
            ++selectedItem;
        }
    }

    bool selectItem() {
        if (selectedItem == 0) { // "Back/Up/Exit" is always the first item
            if (previousMenu != nullptr) {
                selectedItem = previousMenu->lastSelectedItem;
                *this = *previousMenu;
            }
            return false;
        } else {
            if (entries[selectedItem].action) {
                entries[selectedItem].action(entries[selectedItem]);
            }
            return true;
        }
    }

    const std::string& getHeading() const { return heading; }
    const std::vector<MenuItem>& getEntries() const { return entries; }
    size_t getSelectedItemIndex() const { return selectedItem; }
    bool isRootMenu() const { return previousMenu == nullptr; }

private:
    std::string heading;
    std::vector<MenuItem> entries;
    std::vector<Menu*> subMenus;
    size_t currentLevel;
    size_t selectedItem;
    size_t lastSelectedItem;
    Menu* previousMenu;
};

// Function to toggle the title of a menu item
void toggleMenuItemTitle(Menu::MenuItem& item) {
    if (item.title.find(" - On") != std::string::npos) {
        item.title = item.title.substr(0, item.title.find(" - On")) + " - Off";
        item.state = false;
    } else if (item.title.find(" - Off") != std::string::npos) {
        item.title = item.title.substr(0, item.title.find(" - Off")) + " - On";
        item.state = true;
    }
}

void setup(Menu& rootMenu) {
    rootMenu.addMenuItem("Toggle Option - Off", true, false, toggleMenuItemTitle);

    // Create Submenu Alpha
    Menu* submenuAlpha = new Menu("Sub Level Alpha");
    submenuAlpha->addMenuItem("Alpha Option 1", true, false);
    submenuAlpha->addMenuItem("Alpha Option 2", true, false);
    rootMenu.addSubMenu("Sub Level Alpha", submenuAlpha);

    // Create Submenu Beta
    Menu* submenuBeta = new Menu("Sub Level Beta");
    submenuBeta->addMenuItem("Beta Option 1", true, false);
    submenuBeta->addMenuItem("Beta Option 2", true, false);
    rootMenu.addSubMenu("Sub Level Beta", submenuBeta);
}

void printMenu(const Menu& menu) {
    std::cout << "\n" << menu.getHeading() << "\n";
    std::cout << std::string(menu.getHeading().length(), '=') << "\n";
    
    const auto& entries = menu.getEntries();
    for (size_t i = 0; i < entries.size(); ++i) {
        if (entries[i].visible) {
            std::cout << (i == menu.getSelectedItemIndex() ? " > " : "   ") << entries[i].title << (entries[i].state ? " [On]" : " [Off]") << "\n";
        }
    }
    std::cout << " > Back/Up/Exit\n";
}

void runMenu(Menu& menu) {
    char input;
    while (true) {
        printMenu(menu);
        std::cout << "Enter input (w: Up, s: Down, d: Select): ";
        std::cin >> input;
        
        switch (input) {
            case 'w': // Up arrow
                menu.navigateUp();
                break;
            case 's': // Down arrow
                menu.navigateDown();
                break;
            case 'd': // Right arrow (select)
                if (!menu.selectItem()) {
                    return;  // Exit if 'Back/Up/Exit' is selected
                }
                break;
        }
    }
}

int main() {
    Menu rootMenu("Main Menu");
    setup(rootMenu);
    runMenu(rootMenu);

    return 0;
}
